= Introduction =

RoboCup3D agents are modelled as articulated rigid bodies and can be thought of as limbs connected via hinges.  In order to move the limbs, your agent software controls the hinge angles.

= Hinge Anatomy =

The physical hinge is accompanied by two active components:

 # A sensor that measures the angle of the hinge, called a *[Perceptors#HingeJointPerceptor HingeJointPerceptor]*.
 # A motor that changes the angle of the hinge, called a *[Effectors#HingeJointEffector HingeJointEffector]*.

When a hinge's angle is zero, then the axes of the two limbs it joins are parallel.  For example, when the elbow hinge is at zero degrees, the arm is straight.  Similarly, when the knee is at zero degrees, the leg is straight.

[Nao] has 22 hinges in his body.  So we say that Nao has 22 _degrees of freedom_ (DOF).  When all of Nao's hinges are at zero degrees he is standing upright, looking straight ahead and with arms extended out in front of him, like a zombie.

= Reading Current Hinge Position =

The current state of all hinge joints is available via `PerceptorState`.  For convenience, all of Nao's hinges are defined on the `NaoHinge` class.  You can use them together like this:

{{{
Angle currentAngle = state.GetHingeJointAngle(NaoHinge.HJ1);
Console.WriteLine("Nao's neck is at an angle of {0}", currentAngle.Degrees);
}}}

= Moving a Hinge =

The most basic way of manipulating a hinge is to set its speed:

{{{Body.HJ1.DesiredSpeed = AngularSpeed.FromDegreesPerSecond(15);}}}

However, in practice this rarely turns out to address your needs.  Usually you want to attain a specific angle.  At the lowest level, a desired speed is sent to the simulation server, so it is up to your agent to determine what series of speeds to request of the hinge in order to achieve that angle.

The effector remembers the speed value set for each hinge.  If, during the next call to `IAgent.Think`, you don't set a new speed for that hinge then the hinge will continue moving until it reaches its extremity.

= Hinge Limits =

Just like real hinges, simulated hinges can only move through a given arc.  The `Hinge` class defines these limits:

{{{
// Prints: Nao's neck can rotate from -120 to 120 degrees.
Console.WriteLine("Nao's neck can rotate from {0} to {1} degrees.",
                  NaoHinge.HJ1.MinAngle.Degrees,
                  NaoHinge.HJ1.MaxAngle.Degrees);
}}}

Some convenience methods are defined on the `Hinge` class as well:

{{{
var badAngle = Angle.FromDegrees(121);

// Throws ArgumentOutOfRangeException
NaoHinge.HJ1.ValidateAngle(badAngle);

// Returns false
NaoHinge.HJ1.IsValidAngle(badAngle);

// Returns the closest valid angle for the hinge
var goodAngle = NaoHinge.HJ1.LimitAngle(badAngle);
}}}

=Hinges in Practice=

RoboCup3D attempts to provide a realistic simulation of how a real robot would perform in the real world.

 * Physics is simulated, including gravity, inertia and friction
 * [Perceptors] have calibration error and random noise
 * Joint [effectors] are modelled as electric motors

It's important to note that your agent's hinges do not, by default, have any feedback loop built in.  Any control circuitry must be built explicitly into your agent.  This gives quite a bit of flexibility but can be complex.  This page aims to break down the complexity.

=Characterising a Hinge=

In order to understand how hinges are modelled, let's run through some experiments.

Let's apply a very short burst of 'force' to a shoulder hinge and see how far the arm moves before coming to rest.

Here's an implementation of `IAgent.Step` that does this:

TBC

<wiki:comment>
[http://en.wikipedia.org/wiki/Servo_drive Servo drive]
A servo drive is a special electronic amplifier used to power electric servo motors. It monitors feedback signals from the motor and continually adjusts for deviation from expected behavior.
</wiki:comment>

<wiki:comment>
{{{
public void Think(ISimulationContext context, PerceptorState state)
{
    var speed = AngularSpeed.FromDegreesPerSecond(200);
    bool isIncreasing = (state.SimulationTime.Seconds%2==0);

    // Set the neck hinge speed
    Body.HJ1.Speed = isIncreasing ? speed : -speed;
}
}}}

That code moves `HJ1` (the neck) back and forth at 200 degrees/sec, alternating every second of the simulation.  This `Step` method will be called every 20 milliseconds of simulated time (which may be slower or faster than real time).  Nao will stand there shaking his head, indefinitely.  Of course, while he's doing this his camera is reading the location of landmarks on the field, the ball and other players, all of which are being provided to this method as properties of the `PerceptorState` passed into this `Step` method.

Sometimes you need to move part of the body to an exact angle.  As only angular speeds may be sent to the hinge motor, we need a way of controlling the motion of the hinge with a negative feedback loop.

{{{
public void Think(ISimulationContext context, PerceptorState state)
{
    // Alternate between +/- 45 degrees, switching every two seconds
    bool isIncreasing = state.SimulationTime.Seconds%4 >= 2;
    var targetAngle = Angle.FromDegrees(isIncreasing ? 45 : -45);

    // Move Nao's left arm, at the first joint
    MoveToAngle(_body.LAJ1, targetAngle);
}

private static void MoveToAngle(Hinge hinge, Angle targetAngle)
{
    // The speed we set is a factor of the distance.  As we approach the
    // target angle, the distance decreases and so does the angular speed.
    Angle angularDistance = targetAngle - hinge.Angle;

    // If we're within one degree of the target, completely stop the hinge moving.
    if (angularDistance.Abs < Angle.FromDegrees(1))
      hinge.Speed = AngularSpeed.Zero;
    else
      hinge.Speed = angularDistance / TimeSpan.FromSeconds(5);
}
}}}

Note that we must set a value of zero for the hinge's speed in order for the hinge to stop moving.  Each hinge maintains the same speed value across multiple simulation cycles unless it is changed.

There is no single approach for moving hinges to a particular angle.  You may want to use several approaches within the one agent for different scenarios, needing precision in one case and power in another.
</wiki:comment>